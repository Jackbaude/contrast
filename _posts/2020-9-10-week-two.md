---
title:  "Week 2"
mathjax: true
layout: post
description: "My deep delve into Rust Programming langauge"
category : "blog post"
tags: "week 2, rust, ownership, structs, data-types"
---
![rust](https://www.rust-lang.org/static/images/rust-logo-blk.svg) 
# Learning Rust Week 2
---
# Ownership
 In esscense this code breaks because in order to get past a *double free error* which is when s1 goes out of scope s2 and s1 will try to get rid of the values in the heap. To resolve this, rust invalidates s1 when it is **moved** to s2, **NOT** copied. Read the offical documentaion notes down here....
```rust
fn main(){
    /*
    Earlier, we said that when a variable goes out of scope, Rust automatically calls the drop
    function and cleans up the heap memory for that variable. But Figure 4-2 shows both data
    pointers pointing to the same location. This is a problem: when s2 and s1 go out of scope,
    they will both try to free the same memory. This is known as a double free error and is one
    of the memory safety bugs we mentioned previously. Freeing memory twice can lead to memory
    corruption, which can potentially lead to security vulnerabilities.

    To ensure memory safety, there’s one more detail to what happens in this situation in Rust.
    Instead of trying to copy the allocated memory, Rust considers s1 to no longer be valid and,
    therefore, Rust doesn’t need to free anything when s1 goes out of scope. Check out what happens
    when you try to use s1 after s2 is created; it won’t work:
     */




    /*
    If you’ve heard the terms shallow copy and deep copy while working with other languages,
    the concept of copying the pointer, length, and capacity without copying the data probably
    sounds like making a shallow copy. But because Rust also invalidates the first variable, instead
     of being called a shallow copy, it’s known as a move. In this example, we would say that s1 was
     moved into s2. So what actually happens is shown in Figure 4-4.
     */
    let s1 = String::from("hello");
    let s2 = s1;

    println!("{}, world!", s1);
}
```


### Ownership in Functions works a little something like this:
```rust
fn main() {
    let s = String::from("hello");  // s comes into scope

    takes_ownership(s);             // s's value moves into the function...
    // ... and so is no longer valid here

    let x = 5;                      // x comes into scope

    makes_copy(x);                  // x would move into the function,
    // but i32 is Copy, so it’s okay to still
    // use x afterward

} // Here, x goes out of scope, then s. But because s's value was moved, nothing
// special happens.

fn takes_ownership(some_string: String) { // some_string comes into scope
    println!("{}", some_string);
} // Here, some_string goes out of scope and `drop` is called. The backing
// memory is freed.

fn makes_copy(some_integer: i32) { // some_integer comes into scope
    println!("{}", some_integer);
} // Here, some_integer goes out of scope. Nothing special happens.
```

Ownership can also be passed through return values as seen in here...
```rust
fn main() {
    let s1 = gives_ownership();         // gives_ownership moves its return
                                        // value into s1

    let s2 = String::from("hello");     // s2 comes into scope

    let s3 = takes_and_gives_back(s2);  // s2 is moved into
                                        // takes_and_gives_back, which also
                                        // moves its return value into s3
} // Here, s3 goes out of scope and is dropped. s2 goes out of scope but was
  // moved, so nothing happens. s1 goes out of scope and is dropped.

fn gives_ownership() -> String {             // gives_ownership will move its
                                             // return value into the function
                                             // that calls it

    let some_string = String::from("hello"); // some_string comes into scope

    some_string                              // some_string is returned and
                                             // moves out to the calling
                                             // function
}

// takes_and_gives_back will take a String and return one
fn takes_and_gives_back(a_string: String) -> String { // a_string comes into
                                                      // scope

    a_string  // a_string is returned and moves out to the calling function
}
```


But what if we want to pass a data type into an argument but we dont want to for it to go out of scope because what if we need to do something else later.
That is when the `&` operator comes in. The `&` operator is the refrencing operator which can simply just borrow the value. For example in this code:

```rust
fn main() {
    //s1 brought into scope
    let s1 = String::from("hello");
    // s1 would be taken out of scope, but we use the & operator which 
    //just refrences that.
    let len = calculate_length(&s1);

    println!("The length of '{}' is {}.", s1, len);
}

fn calculate_length(s: &String) -> usize {
    s.len()
}
```

But what now if you want to mutaute the refrence variable? Just as variables in rust are immutatble so are refrences so to solve this problem simply...
```rust
fn main() {
    let mut s = String::from("hello");

    change(&mut s);
}

fn change(some_string: &mut String) {
    some_string.push_str(", world");
}
```
## Using Structs

A struct, or structure, is a custom data type that lets you name and package together multiple related values that make up a meaningful group. If you’re familiar with an object-oriented language, a struct is like an object’s data attributes. For example here is a simple struct example,
```rust
struct User {
    username: String,
    email: String,
    sign_in_count: u64,
    active: bool,
}
```
We can also define Structs as return values such as seen here
```rust
fn build_user(email: String, username: String) -> User {
    User {
        email: email,
        username: username,
        active: true,
        sign_in_count: 1,
    }
}
```
## Methods
Methods and functions are mostlye the same thing and work the same way. Except, methods are different from functions in that they’re defined within the context of a struct (or an enum or a trait object, which we cover in Chapters 6 and 17, respectively), and their first parameter is always self, which represents the instance of the struct the method is being called on.

To define the function within the context of Rectangle, we start an `impl` (implementation) block. Then we move the area function within the `impl` curly brackets and change the first (and in this case, only) parameter to be self in the signature and everywhere within the body. For example...

```rust
#[derive(Debug)]
struct Rectangle {
    width: u32,
    height: u32,
}

impl Rectangle {
    fn area(&self) -> u32 {
        self.width * self.height
    }
}

fn main() {
    let rect1 = Rectangle {
        width: 30,
        height: 50,
    };

    println!(
        "The area of the rectangle is {} square pixels.",
        rect1.area()
    );
}
```
